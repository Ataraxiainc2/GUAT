<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Visualización de Datos con D3.js</title>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.js"></script>
    <style>
        body {
            font-family: 'Arial', monospace;
            background-color: #15202B;
            color: #FFFFFF;
            margin: 0;
            padding: 0;
            user-select: none
        }

        #chart-container {
            width: 100%;
            height: 100%;
        }

        #formula-button {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #1da1f2;
        color: white;
        border: none;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        cursor: pointer;
        border-radius: 5px;
    }

    #formula-button:hover {
        background-color: #1089bf;
    }
    </style>
</head>
<body>
    <a href="Formulas.html">Ver Fórmulas</a>
    <div id="chart-container">
    </div>
    <script>
        // Obtener el tamaño de la pantalla
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;

        //La fuente inicial toma en cuenta el tamaño de la ventana usada
        let baseFontSize = Math.min(windowWidth, windowHeight) * 0.011;

        // Carga de datos y creación de la visualización
        d3.json("https://raw.githubusercontent.com/Ataraxiainc2/C-H-N/master/source/repos/Formula%20de%20la%20calidada%20del%20software/Formula%20de%20la%20calidada%20del%20software/datos.json").then(function (data) {
            const padding = 2;
            const width = document.documentElement.clientWidth - 2 * padding;
            const height = document.documentElement.clientHeight - 2 * padding;
            const margin = { top: padding, right: 500, bottom: padding, left: padding };

            let root = d3.hierarchy(data);
            const tree = d3.tree()
                .size([height - margin.top - margin.bottom, width - margin.left - margin.right])
                .separation((a, b) => {
                    let separation = (a.parent === b.parent ? 1 : 2) / a.depth;
                    return separation * 0.1;  // incrementar el factor de separación
                });

            tree(root);

            root.descendants().forEach(node => {
                node.x0 = node.x;
                node.y0 = node.y;
                if (node.depth > -0) {
                    if (node.children) {
                        node._children = node.children;
                        node.children = null;
                    }
                }
            });

            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.zoom().on("zoom", function (event) {
                    linkGroup.attr("transform", event.transform);
                    nodeGroup.attr("transform", event.transform);
                    textGroup.attr("transform", event.transform);
                }));

            const linkGroup = svg.append("g")
                .attr("fill", "none")
                .attr("transform", `translate(0,${margin.top})`);

            const nodeGroup = svg.append("g")
                .attr("transform", `translate(0,${margin.top})`);

            const textGroup = svg.append("g")
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 2)
                .style("font", "16px 'Arial', monospace")
                .attr("transform", `translate(0,${margin.top})`);

            function update(source) {
                const duration = d3.event && d3.event.altKey ? 2500 : 250;
                const treeData = tree(root);
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                const node = nodeGroup.selectAll("g")
                    .data(treeData.descendants(), d => d.id);

                const nodeEnter = node.enter().append("g")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .on("click", function (event, d) {
                        if (d.children || d._children) { // Solo actualiza si el nodo tiene hijos
                            if (d.children) {
                                d._children = d.children;
                                d.children = null;
                            } else {
                                d.children = d._children;
                                d._children = null;
                            }
                            update(d);
                        }
                    });

                nodeEnter.append("circle")
                    .attr("r", d => 5 / (1 + 1 * d.depth))
                    .attr("fill", d => d.data.color || "white");

                const text = nodeEnter.append("text")
                    .attr("dy", function (d) {
                        // si el nodo no se ha expandido, centrar el texto
                        if (d.children == null) {
                            return "0.3em";  // ajustar este valor para centrar el texto
                        }
                        // si el nodo se ha expandido, colocar el texto arriba
                        else {
                            return "-0.2em";
                        }
                    })
                    .attr("x", 5)  // inicialmente, alinear el texto a la derecha del nodo
                    .text(d => d.data.name + (d.data.grade ? " (" + d.data.grade + ")" : ""))  // Aquí se añaden las notas después de cada etiqueta
                    .attr("fill", d => d.data.color || "white")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                    .attr("stroke", "none")
                    .style("font-size", function (d) {
                        let bbox = this.getBBox();
                        let textWidth = bbox.width;
                        let textHeight = bbox.height;
                        let availableWidth = width - d.y;
                        let siblingDistance = Infinity;

                        if (d.parent) {
                            let nodeIndex = d.parent.children.indexOf(d);
                            if (nodeIndex < d.parent.children.length - 1) {
                                siblingDistance = d.parent.children[nodeIndex + 1].x - d.x;
                            } else if (nodeIndex > 0) {
                                siblingDistance = d.x - d.parent.children[nodeIndex - 1].x;
                            }
                        }

                        let fontSize = Math.min(baseFontSize / (1 + 0.1 * d.depth), availableWidth / textWidth * 24, siblingDistance / textHeight * 24);
                        fontSize = fontSize * (1 - 0.05 * d.depth);
                        fontSize = Math.max(fontSize, 2);
                        return fontSize + "px";
                    });

                let hoverFontSize = Math.min(windowWidth, windowHeight) * 0.011;
                text
                    .on("mouseenter", function (event, d) {
                        d3.select(this).style("font-size", hoverFontSize + "px");
                    })
                    .on('mouseleave', function (d) {
                        d3.select(this).attr('stroke', 'none');
                    })
                    .on("mouseleave", function (d) {
                        d3.select(this).style("font-size", function (d) {
                            let bbox = this.getBBox();
                            let textWidth = bbox.width;
                            let textHeight = bbox.height;
                            let availableWidth = width - d.y;
                            let siblingDistance = Infinity;

                            if (d.parent) {
                                let nodeIndex = d.parent.children.indexOf(d);
                                if (nodeIndex < d.parent.children.length - 1) {
                                    siblingDistance = d.parent.children[nodeIndex + 1].x - d.x;
                                } else if (nodeIndex > 0) {
                                    siblingDistance = d.x - d.parent.children[nodeIndex - 1].x;
                                }
                            }

                            let fontSize = Math.min(baseFontSize / (1 + 0.1 * d.depth), availableWidth / textWidth * 24, siblingDistance / textHeight * 24);
                            fontSize = fontSize * (1 - 0.05 * d.depth);
                            fontSize = Math.max(fontSize, 2);
                            return fontSize + "px";
                        });
                    });
                const nodeUpdate = node.merge(nodeEnter).transition().duration(duration)
                    .attr("fill-opacity", 1)
                    .attr("stroke-opacity", 1)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .end().then(() => {
                        node.attr("transform", d => `translate(${d.y},${d.x})`);

                        text.attr("x", function (d) {
                            let text = this;
                            let textLength = text.getComputedTextLength();
                            let xPosition = 5;  // posición inicial a la derecha del nodo

                            // si el nodo se ha expandido y no está en la tercera jerarquía, ajusta la posición x para que el final del texto coincida con el inicio del nodo
                            if (d.children != null && d.depth != 3) {
                                xPosition -= textLength + 15;  // mover el texto a la izquierda por su ancho
                            }

                            // si el nodo se ha expandido y está en la tercera jerarquía, ajusta la posición x moviéndolo 200 unidades hacia la izquierda
                            if (d.children != null && d.depth == 3) {
                                xPosition -= 200;  // mover el texto a la izquierda por 200 unidades
                            }

                            return xPosition;
                        });
                    });

                const nodeExit = node.exit()
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .transition().duration(duration)
                    .remove();

                const link = linkGroup.selectAll("path")
                    .data(treeData.links(), d => d.target.id);

                const linkEnter = link.enter().append("path")
                    .attr("fill", "none")
                    .attr("stroke", d => d.target.data.color || "#808080")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5)
                    .attr("d", d => {
                        const o = { x: source.x0, y: source.y0 };
                        return d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x)({ source: o, target: o });
                    });


                const linkUpdate = link.merge(linkEnter).transition().duration(duration)
                    .attr("d", d => {
                        return d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x)(d);
                    });

                const linkExit = link.exit()
                    .transition().duration(duration)
                    .attr("d", d => {
                        const o = { x: source.x, y: source.y };
                        return d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x)({ source: o, target: o });
                    })
                    .remove();

                // Para los enlaces que se actualizan
                link.merge(linkEnter).transition().duration(duration)
                    .attr("d", function (d) {
                        if (isNaN(d.source.x) || isNaN(d.source.y) || isNaN(d.target.x) || isNaN(d.target.y)) {
                            return "M0,0";  // Esto dibujará una línea en la posición (0,0) en lugar de fallar
                        }
                        return d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x)(d);
                    });

                link.exit().transition().duration(duration).remove()
                    .attr("d", d => {
                        if (isNaN(source.x) || isNaN(source.y)) {
                            console.log('Invalid source:', source);
                            return;
                        }
                        const o = { x: source.x, y: source.y };
                        return d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x)(d);
                    })
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
            }
            update(root);

            document.getElementById("chart-container").appendChild(svg.node());

            window.addEventListener("resize", function () {
                const width = document.documentElement.clientWidth - 2 * padding;
                const height = document.documentElement.clientHeight - 2 * padding;
                // Actualiza el tamaño del gráfico aquí
            });

            fetch('/datos')
                .then(response => response.json())
        }).catch(function (error) {
        });
    </script>
</body>
</html>
